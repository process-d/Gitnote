## 1、外部一致性、线性一致性和顺序一致性
**外部一致性**：指事务T1执行完成后，T2才启动，保证让T2看到T1的结果。
在Spanner论文中，外部一致性成为Spanner论文要解决的主要问题。
1. T1和T2的时间戳可能属于不同region的server。
2. 不同region间的server之间，时间没法严格同步，存在误差。（虽然Spanner用了很强的硬件以及算法来同步时钟，仍然不能绝对保证跨region的服务器的时钟严格同步。因为跨了延迟达到100ms的广域网）
**顺序一致性**：如果一个并发执行过程所包含的所有读写操作能够重排成一个全局有序的序列。并且这个序列满足以下两个条件，那么这个并发执行过程满足顺序一致性的。
1. 重排后的序列中每一个读操作返回的值，必须等于前面对同一个数据对象的最近一次写操作所写入的值。
2. 原来每个进程中各个操作的执行先后顺序，在这个重排后的序列中必须保持一致。
**线性一致性**： 在顺序一致性之上，多了一个条件。又称为强一致性，原子一致性
1. 重排后的序列中每一个读操作返回的值，必须等于前面对同一个数据对象的最近一次写操作所写入的值。
2. 原来每个进程中各个操作的执行先后顺序，在这个重排后的序列中必须保持一致。
3. **不同进程的操作，如果在时间上不重叠，那么他们的执行先后顺序，在这个重排后的序列中必须保持一致。**
对于第3点：要重点注意在时间不重叠，如果在时间重叠如C和D的R（x，1），两者谁在前都可以，都满足线性一致性的定义。
**例子：**
![[Pasted image 20230828162653.png|900]]
如果可以找到一个所有 CPU 执行指令的排序，该排序中每个 CPU 要执行指令的顺序得以保持，且实际的 CPU 执行结果与该指令排序的执行结果一致，则称该次执行达到了顺序一致性。

注意到顺序一致性关心的是 CPU 内部执行指令的顺序，而不关心 CPU 之间的相对顺序。**这是顺序一致性和线性一致性的区别。这也是为什么顺序一致性会读到旧值的原因。**
继续，将上图的 C:R(X, 1) 与 D:R(X, 2) 替换一下
![[Pasted image 20230828163629.png]]
也可以找到一个满足要求的全局排序，所以系统依旧满足顺序一致性。
**再将原图的 D:R(X, 1) 和 D:R(X, 2) 互换**
![[Pasted image 20230828165113.png]]
对于上图的系统，实际上是找不到一个全局的排序来满足顺序一致性的需求的。
顺序一致性很难，现代的多核CPU依然达不到顺序一致性
![[Pasted image 20230828165100.png]]

如果 CPU 如上图执行，得到的结果不满足顺序一致性。
没有了顺序一致性的保证，程序居然还能正确执行。其实，现代硬件体系遵循的其实是：如果程序没有数据竞争，则 CPU 可以保证顺序一致性，而如果遇到数据竞争，就需要程序里手动使用一些数据同步的机制（如锁）。

两者的不同：
- 在顺序一致性中，我们可能读到旧版本的数据
-  顺序一致性保证了执行顺序不会被打乱，体现在条件二对于进程内各个操作的排序保持上。
- 线性一致性考虑了所有服务器的时间先后顺序，而顺序一致性没有。
- 满足线性一致性的执行过程，肯定满足顺序一致性；反之不一定。
- 线性一致性隐含了时效性保证，他保证总是读到最新的值。

## 2、事务
事务是数据库提供的一种机制，所有操作要么全部执行，要么都不执行。
### 2.1 、单机事务
**1. 并发控制（concurren control）**
- 乐观锁：版本号和时间戳（MVCC）
- 悲观锁：两阶段锁协议（2PL）
**2. 原子性提交（Automatic commit）**
- 日志：WAL机制
### 2.2、分布式事务
两个服务器个执行一个操作，要么同时执行，要么都不执行。涉及到多个服务器，要考虑服务器故障和通信问题。
对于分布式事务，就是把事务和一致性结合。则一致性表示的是物理时间上不相交的两个事务的可见性，而物理时间上相交的两个事务的可见性由隔离性决定。
**1、2PC**（two phase commit）
 包括一个协调者（coordinator）和多个参与者（Participants）。协调者负责引导整个提交过程，而参与者负责执行事务操作。
 事务的执行分成**准备阶段**和**提交阶段**。
 1、**准备阶段**
   ![[Pasted image 20230828171906.png]]
  1. 事务询问：协调者向所有的参与者发送事务预处理请求，称之为Prepare，并开始等待各参与者的响应。
  2. 执行本地事务：各个参与者节点执行本地事务操作,但在执行完成后并不会真正提交数据库本地事务，而是先向协调者报告说：“我这边可以处理了/我这边不能处理”。
  3. 各参与者向协调者反馈事务询问的响应：如果参与者成功执行了事务操作，那么就反馈给协调者Yes响应，表示事务可以执行，如果没有参与者成功执行事务，那么就反馈给协调者No响应，表示事务不可以执行。
 2、**提交阶段**
   ![[Pasted image 20230828172014.png]]
   1. 协调者节点通知所有的参与者Commit事务请求；
   2. 参与者收到Commit请求之后，就会正式执行本地事务Commit操作，并在完成提交之后释放整个事务执行期间占用的事务资源。
 如果是在提交阶段之前的崩溃是比较好处理的，因为此时数据还没有落盘。
 3、**两阶段提交的问题**
   1. 同步阻塞问题。执行过程中，所有参与节点都是事务阻塞型的。
   2. 单点故障。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。
   3. 数据不一致。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，导致只有一部分参与者接受到了commit请求。而这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。
   4. 二阶段无法解决的问题：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。
一般的语言不能直接操作寄存器，而汇编可以，可以在某种语言（c语言）嵌入汇编代码来操作硬件寄存器。
asm 申明内联汇编表达式
volatile 告知编译不要优化代码
**内联汇编格式**：
asm volatile("")
asm  volatile("mov1 $1,%exa")
asm volatile("mov1 $1,%exa";pushl %eax)  两条汇编指令可以放在一起，通过;分割符进行分割。
理解xv6只要知道这么多就行了。
#### IO设备访问的两种方式：IO映射访问和内存映射访问
**IO端口映射访问**：访问IO就是访问外设的一些端口，这里所说的端口就是外设的一些寄存器，而外设的寄存器并不一定是端口。端口的数量支持有限，比如 xv6只支持65536个8位端口，形成独立于内存的64KB 的IO地址空间。 但外设的寄存器是有很多的，65536个端口不够用，所以有了index/data的方式来访问外设的寄存器。外设提供两个端口 index和data，用index端口指定其他的寄存器，从 data 端口读写这个寄存器。（外设的寄存器不能全都当成端口访问，有一部分是通过index/data方式访问）
上述所说的访问IO的方式叫做IO端口映射，这种映射方式是将外设的IO端口看成一个独立的地址空间，访问这片空间不能用访问内存的指令，需要专门的in/out 指令来访问。
**IO内存映射**：内存映射就是把这些寄存器看作内存的一部分，读写内存，就是 写内存，就是读写外设的寄存器，可以用访问内存的指令比如 mov 来来访问寄存器 ，比如说APIC的一些寄存器就是内存映射的。
这就是访问IO的两种方式，但是IO能随意访问的吗？当然不是， IO的访问也是有特权级检查的，就算是内存映射直接读写内存的形式， 但是这部分内存都是映射到虚拟地址的高地址也就是内核部分，只有内核(0 特特权级)才有权操作。
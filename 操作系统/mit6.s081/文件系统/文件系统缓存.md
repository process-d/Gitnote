![[Pasted image 20230831220528.png]]
内存不是全部作为磁盘的缓存，而是只有一部分作为磁盘的缓存。其他内存空间作为其他硬件的缓存或者进程的空间。
```c
struct buf {
  int valid;   // has data been read from disk? 数据是否已经从磁盘中读取了一级是否为脏页  
  int disk;    // does disk "own" buf?  是否为磁盘专属的buf  
  uint dev;  // 缓存了什么设备的数据
  uint blockno;  // 磁盘块号
  struct sleeplock lock; 
  uint refcnt;  // 引用该块的数量
  struct buf *prev; // LRU cache list 该块的前一个块  
  struct buf *next; //后一个块
  uchar data[BSIZE]; //数据
}
struct {
  struct spinlock lock;
  struct buf buf[NBUF];
  struct buf head; // 这是一个双向循环链表
} bcache
```
buf中的sleeplock是在进行磁盘请求时，进入sleep状态，从而放弃CPU。

对缓存的进行管理的函数（bio.c）有**binit、bget、bread、bwrite、brelse、bpin、bunpin**。
**binit**：对bcache进行初始化，对buf的锁和双向链表进行初始化。
**bget**:  查找blockno是否在缓存中，不在，就分配一个引用为0的缓存块。bget函数返回时，获取了缓存块的锁，并且将refcnt和blockno赋值，但是没有添加数据。
**brelse**：释放指定的缓存块，如果refcnt为0，真正释放，否则只是将refcnt-1。
**bread**：调用bget函数，获取磁盘缓存块，调用磁盘驱动程序，读取数据，期间会调用进程管理的sleep函数，将进程状态改为sleeping，释放cpu，切换到调度程序。
**bwrite**：将一个buf中的数据写入磁盘，
**bpin**：将buf的refcnt+1
**unpin**：将buf的refcnt-1

操作系统提供了一系列直接操作磁盘块的函数，实际上因为操作系统中的进程对磁盘块进行操作都需要**经过buffer cache**缓存，所以本质上还是buffer cache的函数的封装调用。

**bzero(int dev, int bno)**：将bno号的磁盘块的数据清空。需要先将磁盘块读入到内存，然后将对磁盘块的操作写入到日志。
**balloc(uint dev)**：利用bitmap找出一块空闲的磁盘块，
**bfree**：释放缓存块。
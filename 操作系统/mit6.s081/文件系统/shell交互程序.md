shell的命令操作也是有很多东西，命令的分类，命令的解析，命令的执行。
shell中有两个机制：**重定向**和**管道**
**重定向实现的底层原理**
首先在fork一个进程后，将进程的文件描述符1关闭，因为文件描述符是从小到大进行分配。因此只需要调用close函数关闭一个文件描述符，在open一个文件分配一个文件描述符，此时分配的文件描述符必定是1，也就是输出描述符了。
**管道**
xv6中在命令行使用 | 来表示管道，左右两边表示输入和输出。管道也是一种文件，也有文件描述符，也分配了内存来存储数据。跟管道相关的函数：
**pipealloc**: 创建管道，为管道分配两个文件描述符，为管道分配内存，调用kalloc。
**pipeclose**: 只有读写两端都关闭了，再把管道的内存回收。
**piperead**: 读取管道中的数据
**pipewrite**:向管道中写入数据
```c
//管道结构体
struct pipe {
  struct spinlock lock;
  char data[PIPESIZE];
  uint nread;     //存放数据的内存区域  
 uint nwrite;    // number of bytes written  
  int readopen;   // 可读的一端是打开的？ 
 int writeopen;  // write fd is still open  
}
```
**控制台程序**
计算机启动时进程创建了一个控制台文件，此时文件表中有一个控制台文件结构体，文件描述符 0 指向这个结构体，然后 dup 两次创建了文件描述符 1、2，使得它俩也指向控制台文件结构体。所以使用文件描述符 0、1、2 读写数据就是读写控制台文件，也就是常说的的标准准输入/输出/错误，这也是一切皆文件思想的运用 。

fork会复制一份进程的文件描述符表，所有进程都可以看作是进程的子进程，所以每个进程至少都有三个文件描述符， 0、1、2，分别表示标准准输入，标准输出，标准错误。
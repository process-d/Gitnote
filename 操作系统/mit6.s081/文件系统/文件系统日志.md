
![[Pasted image 20230831223513.png|磁盘总体布局]]
如果一个操作涉及到对磁盘不同的块的读写操作，写的过程中系统崩溃，磁盘的数据一致性很难保证，因此保证对多个磁盘块的写操作的原子性就很重要了。通过日志来解决因为崩溃导致的不一致问题，保证了多个写操作的原子性。

操作系统先将对缓存块写入磁盘操作包装成一个日志操作，写入到日志区，等到日志提交到磁盘区，对缓冲块的写操作才算完成。
```c
struct superblock {
  uint magic;        // Must be FSMAGIC  
  uint size;         // Size of file system image (blocks)  
  uint nblocks;      // Number of data blocks  
  uint ninodes;      // Number of inodes.  
  uint nlog;         // Number of log blocks  
  uint logstart;     // Block number of first log block  
  uint inodestart;   // Block number of first inode block  
  uint bmapstart;    // Block number of first free map block  
}
struct logheader {
  int n; //当前日志使用空间大小
  int block[LOGSIZE]; //Block[1] = 1024表示日志块1记录的数据放在1024号磁盘块
};
struct log {
  struct spinlock lock;
  int start;//日志区第一块块号
  int size;//日志区大小
  int outstanding; // 有多少文件系统调用正在执行  
  int committing;  // 正在提交
  int dev;//设备，即主盘还是从盘，文件系统在从盘
  struct logheader lh;//日志头
}
```
**日志操作的相关函数**
**readsb**：读取超级块(superblock)的内容到内存，超级块的内容在磁盘的1号磁盘块。
**initlog**：初始化log的参数，start、size和dev还有lock，最后调用recover_from_log函数
**install_trans**：将日志块的数据写入到对应的磁盘块中。
**read_head**：读取日志头信息，日志头在日志的第一个磁盘块。
**write_head**: 将日志头信息写入磁盘。
**recover_from_log**：read_head函数读取日志头，调用install_trans，将数据从日志区写到数据区，将日志记录清空，同步日志头信息到磁盘。
**begin_op**：在xv6中每一个文件系统调用可能写入一定数量（10）的磁盘块，在此函数中，会对日志区的状态（是否正在提交）进行检查，是的话就sleep，同时对所有正在执行的文件系统的调用（outstanding）总的写入日志块的数量不能大于日志区。然后只是将outstanding+1，表明开始一个新的文件系统调用。
**end_op**：是begin_op相反的操作，它表示系统调用结束，将outstanding减 1。如果减为 0，表示当前没有文件系统调用在进行，则可以提交事务了，end_op将要写入的磁盘号放入到logheader中：设置commiting和 do_commit属性为 1,调用commit函数，然后唤醒因日志区太小而阻塞的系统调用。
**write_log**：将缓存块的数据写入到日志块，将日志的磁盘块和缓存块读入到内存中，再将缓存块中的数据复制到日志的磁盘块的buf中，再将buf写入磁盘。
**commit**：调用write_log、write_head函数，完成write_head函数表示已经提交了，之后再调用install_trans函数，再将内存中log.lh.n=0，再写入到磁盘，开始下一次事务。
**log_write**：将要写入的磁盘块号放入logheader中，并pin住该缓存块。
**总结：** 日志恢复好像没有那么难，设计的确实好，磁盘的日志区只是包括logheader结构体和其他磁盘块，logheader结构体在日志区的第一页，log结构体是在内存中的，不会保存到磁盘。一个文件系统调用开始包括了begin_op、log_write和end_op（调用了log_write和commit）。



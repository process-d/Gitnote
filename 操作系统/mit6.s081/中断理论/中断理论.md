中断分为了软中断和硬中断
###  软中断和硬中断
**硬中断**由硬件设备触发的中断，一个外设触发的中断的始末会经历设备，中断控制器，CPU &OS 三个阶段：设备产生中断，中断控制器接收和发送中断，CPU&OS来实际处理中断。**硬中断可以屏蔽**，硬中断的处理函数是由硬件驱动程序注册并绑定的。

**软中断**是软件通过系统调用人为产生的，不可屏蔽，软中断的处理函数是由内核函数注册的。

#### 中断控制器（PIC）接收和发送中断
 图为中断控制器8259A芯片，中断控制器也可以看成一个芯片。IR0-IR7的8个引脚，每个引脚可以连接一个外设。因此8259A支持8个中断。通过INT和INTA与CPU的INTR进行通信。8259A芯片只有8个引脚，只支持8个中断，太少了，可以采用级联的方式，就是串联，将另一个8259A芯片接入到一个8259芯片的中断引脚上。中断序号越小，级别越高。
 ![[Pasted image 20230904103102.png|300]]
8259A是芯片，它有几个重要的寄存器。
IRR（Interrupt request register）共8位，对应IRQ0-IRQ7 8个中断引脚
当中断引脚收到信号，IRR中相应的位置为1，表示已收到该设备的中断请求但还未交由处理。
ISR（Interrupt Service Register）共8位，同样的每位表示对应引脚表示的中断，当 IRR中某个中断请求提交给CPU 时，IRR相应的位被清 0， 相应的位就被置1，表示 正CPU处理该中断。
IMR（Interrupt Mask Register）共 8 位，同样的每位表示对应引脚表示的中断，某位置 1 表示屏蔽相应的中断，清 0 表示允许相应的中断。
PR（Priority Register）优先级仲裁寄存器，有多个中断同时发生时，它能找出哪个中 断优先级最高 
EOI（End of Interrupt）在PIC里面EOI不是一个寄存器，而是操作命令寄存器中的一个bit，写 EOI表示中断结束。
**PIC中断流程**
0. IRQ引脚接收到中断信号，若该中断没有被屏蔽，那么IRR中相应的位置为1
1. PIC通过INT向 CPU发送INTR信号
2. CPU通过INTA引脚发送应答信号给PIC
3. PIC收到应答信号后，将IRR中最高优先级的中断相应的位清 0，将ISR相应的位置 1
4. CPU再次发送信号给PIC，PIC收到后将 vector送到数据线
5. CPU根据vector索引IDT中的门描述符，执行中断服务程序
6. 中断处理完成之后写EOI，将ISR中相应的位清 0 表示中断完成
#### CPU和OS处理中断
涉及到的概念有中断描述符表&门描述符&中断向量
中断描述符表  里面存放的是门描述符，有三种门描述符，任务门，中断门，陷阱门。
CPU和OS部分处理中断从CPU获取到中断控制器发来的vector开始，这部分的中断流程
可以分为三个步骤：
1. 保存上下文
2. 执行中断处理程序
3. 恢复上下文
### 思考
- **思考一：进程上下文切换和中断导致的上下文切换应该是不同的吧？**
 由中断引起的上下文切换包括CPU上下文和OS上下文。不过感觉差不多，都是将寄存器存的值压入到内核栈中。CPU上下文包括CS（Code segment,代码段寄存器）+EIP，以及当前是否处于内核态，不处于的话，还需要从用户态进入到内核态。并且保留用户态的寄存器的值。
 指令指针寄存器IP（instruction Pointer）来确定要执行的下一条指令的内存地址
- **思考二：CPU和OS处理中断流程总结**
0. 根据vector去IDT中索引相应的门描述符
1. 判断特权级是否发生变化，如果中断发生在用户态，则需要换成内核栈，切换到内核态
2. 若发生特权级变化，需要保存用户态的 ss_oid，esp_oid到内核栈，否则不需要保存，然后再保存eflags，cs_oid，ip_old 到内核栈中，如果有错误码，还要将错误码压进栈中
3. 根据门描述符中的段选择子再去GDT中索引相应的段描述符得到段基址，与中断描述符里的段偏移量结合起来找到中断服务程序
4. 中断入口程序保存上下文，中断处理程序实际处理中断，中断退出程序恢复一部分上下文
5. 最后执行iret恢复CPU保存的上下文，如果有特权级转移，则换到用户栈回到用户态。
6. 中断完成，接着原任务执行
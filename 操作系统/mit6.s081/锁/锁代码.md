XV6支持多个处理器，对应XV6而言，单个处理器存在竞态关系，比如中断，多个处理器也会对同一资源产生竞争关系，比如内存的物理页。Xv6不支持线程，并且多个进程之间没有共享内存资源。
Xv6种主要有两种锁：**自旋锁（spinlock）** 和**休眠锁（sleeplock）**
**自旋锁的函数**
**initlock**：完成锁的初始化，包括锁的名字，持有该锁的CPU为空，锁的状态为空闲
**acquire**：获取锁之前要关闭中断，并且通过硬件指令来保证获取锁操作的原子性。还通过一个禁止指令重排序函数来防止编译器进行重新排序。
**为什么获取锁之前要关闭中断？**
如果不关闭中断，当前CPU上的进程在获取锁后发生中断，中断处理程序也需要获取相同的锁就会造成死锁。CPU关闭的是自己的中断，不会关闭其他CPU的中断服务。
**holding**：如果已经持有锁，会panic。持有锁的条件是lock state=1和持有锁的cpu是否当前cpu，xv6 不允许同一个 CPU 对 同一个锁重复上锁。
**push_off**：打开中断，还做了一些其他事
**push_on**：关闭中断，还做了一些其他事

**思考一：C语言、操作系统和硬件的关系。**
语言是操作硬件的关键，硬件就像电灯和电灯开关一样，按了开关，灯会亮或者熄灭。有些硬件很复杂，如果只靠开关那需要上百个开关，但是开关就是0和1状态的转变，通过一些指令（语言），然后解析指令，就相当于拨动了硬件内部的一个个开关，使得硬件内部状态发生变化。而操作系统是由各种语言编写的，通过语言（指令）完成了各个硬件之间相互合作，为上层的应用程序提供服务。
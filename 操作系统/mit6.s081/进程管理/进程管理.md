进程的proc结构体就是所谓的PCB（process control block）。进程持有的文件系统的资源是file和inode。在操作系统中，所有进程是构成了一棵树，根节点是第一个进程。
**进程资源的释放：所有的进程的资源释放都是通过父进程来完成的。**
### 进程状态
**进程状态**：{ UNUSED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE }
**ZOMBIE（僵尸状态）**：进程干完活儿就会执行函数，期间状态变为ZOMBIE，这个状态一 直持续到父进程调用 wait来回收子进程资源。如果子进程执行exit退出之后，父进程一直没有调用wait来回收子进程，那么这个子进程就 一直处于僵尸状态，也就是通常所说的僵尸进程。

**孤儿进程**：如果一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将最后会被init进程(第一个进程)所收养，并由init进程对它们完成资源释放的回收工作。
### 进程地址空间
![[Pasted image 20230904140704.png]]
从图中可以看出，堆是被分成了未映射用户空间和已经映射了的用户空间。可以通过sbrk（）函数调用（低层是调用uvmalloc）来使得未映射的用户空间完成映射。proc的sz就可以表明是从那个虚拟地址开始映射。
#### 内核页表和进程页表的虚拟地址和物理地址的映射关系
这是mit6.s081的内核虚拟地址分布图：展示了内核页表中虚拟地址和物理地址的映射关系。
![[Pasted image 20230904141025.png]]
从这张图中可以看出，内核的数据和命令段在KERNBASE以上（0X80），free memory是用来存储进程的数据段和代码段的，而用户进程映射在（0x80以下），内核虚拟地址空间中的虚拟地址是从CLINT开始的，但是有一部分的硬件也映射到了低地址区域。
**蹦床页面(trampoline page)**，它映射在虚拟地址空间的顶部，与用户页表具有相同的映射。
mit6.s081的虚拟地址空间布局是将内核部分放在了低地址处，而内核栈和trampoline page放在了高地址处。
### 进程调度
主要有两个事件会触发进程的调度：
1. 时间片到了，被动放弃CPU
2. 进程阻塞导致调度，主动放弃
#### 调度算法
 **先来先服务**：维护一个队列，进程先来先处理
 **最短进程优先**：维护一个队列，最短进程优先
 **最高优先级**：维护一个优先级的队列。
 **时间片轮转法**：每隔一段时间切换一个进程。
 **多级反馈队列**：设置多个队列，每个队列的优先级和时间片不同。第一个队列的优先级最高，时间片最短。 各个队列的优先级依次降低，时间片依次增长。每个队列按照先来先服务的原则。
 **一个用户进程切换到另一个用户进程的过程**：从用户态进入内核态，其用户态上下文保存在trapframe中，从内核态切换到调度程序，其内核上下文保存在进程结构体中的context中，每一个CPU都有一个context，保存的是调度程序的上下文，最后再从调度程序切换到另外的进程p2，p2进程再从内核态恢复到用户态。
 ![[Pasted image 20230904142410.png]]
**进程上下文(Context结构体)**：
**中断上下文(trapframe结构体)**：当用户程序程序进入内核(中断，系统调用用) ， 需要保存当前进程的现场，也就是将中断前一刻进程的所有寄存器压栈到内核栈，这些寄存器加上一些其他信息比如向量号就形成中断栈帧。
#### 多处理调度
1. 多个CPU共享一个队列
2. 每个CPU都有自己的队列。通过迁移策略来解决CPU的负载不均衡（就是每个CPU的队列的进程数量不同）
#### 调度函数
在内核的main函数运行时，最后会执行内核的scheduler函数，这就是内核的调度线程。
**scheduler函数**：从进程表中找出一个可运行的进程，调用swtch函数。保存调度线程（scheduler）的上下文到CPU的context中，将进程的context读入到相应的寄存器中。
**sched函数**：做一系列安全检查，最后调用swtch函数。
**swtch函数**：完成进程上下文的保存，和切换到调度线程（scheduler）的上下文。
**ra寄存器**：存储了函数的返回地址。




